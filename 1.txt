1.6
（1）用exit语句终止执行并报告错误。优点：风险很低，属于“急停”类型，适用于程序调试时，可及时观察到变量的值，便于了解错误产生的细节；缺点：停止了一切动作，降低了效率。
（2）以函数的返回值确定正确返回或错误返回。优点：没有中断进程，可根据返回值找出错误的原因；缺点：很多情况下函数的返回值是有实际意义的，如果返回值只能有一个，那么会和想要的结果产生混淆，因此不适合单返回值的函数。
（3）设置一个整形变量的函数参数以区别正确返回或某种错误返回。优点：该方法在查错和容错上和返回值相似，但没有占用返回值，因此适用于需要返回实际值的函数。


1.7
（1）通过scanf语句和printf语句。直接与外部环境进行信息交换，复用性较差，仅适用于人机交流时；
（2）通过函数的参数显示传递。和调用环境进行信息交换，安全性好，是模块内部出现的错误不外泄。
（3）通过全局变量隐式传递。交换方式同（2），但安全性差，容易出现各模块的错误滚动传递。

1.8
（1）以n的值为准，如果n<=1,则频度为0，如果n>1，则频度为n-1；
（2）如果n<=1,则频度为1，如果n>2，则频度为n-1；
（3）如果n<=1,则频度为0，如果n>1，则频度为n-1；
（4）依次求和：n+n-1+n-2+...+1，频度为n（n+1）/2；
（5）I=1，j=1时，执行1次，i=2，j=1时，执行1+2次，i=3，j=1,时执行1+2+3次......
可知其频度为n（n+1）/2从i=1累加到i=n次，即为n（n+1）（n+2）/2次；
（6）如果n<1,则频度为0，如果n>=1，则频度为n；
（7）【根号n】；
（8）1100次（100*11）；

//1.16
void output(int x,int y,int z)
{
    scanf("%d %d %d",&x,&y,&z);
    if(x<y)
    {
        x<->y;//伪代码，类似于使用中间值temp的交换函数
    }
    if(y<z)
    {
        y<->z;
    }
    if(x<y)
    {
        x<->y;
    }
    printf("%d %d %d",x,y,z);
}


//1.20
void Accumulate(int n,float x)
{
    float a[n];
    float *p=a;
    printf("input the number from a0 to a%d",n);
    int i;
    for(i=0;i<=n;i++)
    {
        scanf("%f",p++);
    }
    float sum=0,b=1;
    for(i=0;i<=n;i++)
    {
        sum+=b*(*p++);
        b*=x;
    }
    printf("result is %f",sum);
}